# -*- coding: utf-8 -*-
"""Alura_Challenge_1

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Pg4Y3aR9jUQT_UlMl3UOD9tXlO1b6uaC
"""

import os
import requests
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

from openai import OpenAI
from sklearn.preprocessing import LabelEncoder

# Importando dados
try:
  # URL
  url = "https://raw.githubusercontent.com/sthemonica/alura-voz/main/Dados/Telco-Customer-Churn.json"
  response = requests.get(url, timeout=5)
  response.raise_for_status()
  dados = response.json()
  print("Dados carregados com sucesso!")

except requests.HTTPError as e:
  print("Dado não encontrado", e)

# Buscando Dicionário
try:
  url_dict = "https://raw.githubusercontent.com/sthemonica/alura-voz/main/dicionario.md"
  response_dict = requests.get(url_dict)
  response_dict.raise_for_status()
  dicionario = response_dict.text
  print("Dicionário carregado com sucesso!")

except requests.HTTPError as e:
  print("Dicionário não encontrado", e)

print(dicionario)

# Criando DF
df = pd.json_normalize(dados)

df.head()

df.columns = df.columns.str.replace(".", "")
df.columns = df.columns.str.replace("phone", "")
df.columns = df.columns.str.replace("customer", "")
df.columns = df.columns.str.replace("internet", "")
df.columns = df.columns.str.replace("account", "")

df.head(10)

"""#### Dicionário de dados

* `customerID`: número de identificação único de cada cliente
* `Churn`: se o cliente deixou ou não a empresa
* `gender`: gênero (masculino e feminino)
* `SeniorCitizen`: informação sobre um cliente ter ou não idade igual ou maior que 65 anos
* `Partner`:  se o cliente possui ou não um parceiro ou parceira
* `Dependents`: se o cliente possui ou não dependentes
* `tenure`:  meses de contrato do cliente
* `PhoneService`: assinatura de serviço telefônico
* `MultipleLines`: assisnatura de mais de uma linha de telefone
* `InternetService`: assinatura de um provedor internet
* `OnlineSecurity`: assinatura adicional de segurança online
* `OnlineBackup`: assinatura adicional de backup online
* `DeviceProtection`: assinatura adicional de proteção no dispositivo
* `TechSupport`: assinatura adicional de suporte técnico, menos tempo de espera
* `StreamingTV`: assinatura de TV a cabo
* `StreamingMovies`: assinatura de streaming de filmes
* `Contract`: tipo de contrato
* `PaperlessBilling`: se o cliente prefere receber online a fatura
* `PaymentMethod`: forma de pagamento
* `Charges.Monthly`: total de todos os serviços do cliente por mês
* `Charges.Total`: total gasto pelo cliente
"""

df.info()

for coluna in df.columns:
    print(f"Contagem de valores para {coluna}:\n{df[coluna].value_counts()}\n")

# Percorrendo cada coluna e gerando um gráfico de barras
for coluna in df.columns:
    plt.figure(figsize=(6, 4))  # Define o tamanho do gráfico
    df[coluna].value_counts().plot(kind='bar', color='cornflowerblue', edgecolor='black')

    plt.title(f'Distribuição da variável: {coluna}')
    plt.xlabel(coluna)
    plt.ylabel('Frequência')
    plt.xticks(rotation=45)  # Rotaciona os rótulos do eixo X para melhor visualização
    plt.grid(axis='y', linestyle='--', alpha=0.7)  # Adiciona grade no eixo Y

    plt.show()  # Exibe o gráfico

"""# Entendendo Dados

## Tipos de Dados

Senior Citizen, uma categórica, está como inteiro (ok).

Tenure (tempo de contrato), está como inteiro (correto).

Charges Monthly (total da conta por Mês) está como float, (correto).

Charges Total (total gasto pelo cliente em todo contrato) está como objeto (errado)

Todas as outras variáveis estão como objeto e são algum tipo de variável categórica.

## Verificando Integridade dos Dados

Não há dados nulos ou faltantes. Porém, a variável Churn possui algumas contagems com rótulo vazio. Preciso verificar isso.

Algumas variáveis possuem dois tipos de sinalização para "não". "No" e "No phone service" ou "No Internet Service". Preciso alterar isso.

## Distribuição dos Dados

Algumas variáveis estão com a distribuição muito desigual como Churn, SeniorCitizen e Dependents. Isso pode afetar o aprendizado do modelo de previsão.

A variável Ternure mostra uma contagem alta de clientes com poucos meses de contrato.


# Limpeza

1. Entender e tratar as contagens vazias da variável Churn

# Transformações

1. Transformar Variável Multiple Lines o "No phone service" para "No".
2. Transformar Variáveis "OnlineSecurity", "OnlineBackUp", "DeviceProtection", "TechSupport", "StreamingTV" e "StreamingMovies" de "No internet services" para "No".
1. Transformar Charges Total em float.
2. Separar variáveis categóricas das numéricas.
3. Fazer a codificação das Variáveis Categóricas.
"""

df['Churn'].value_counts()

df_churn = df[df['Churn'] == '']
df_churn.head()

"""# Investigação e Limpeza Churn

Realmente temos valores vazios no churn. Como ela será a variável target na criação do modelo, precisamos remover os valores vazios.

Vou transformar em valores nulos para remover as linhas.
"""

df['Churn'] = df['Churn'].replace('', np.nan)

df['Churn'].value_counts()

df.info()

df.dropna(inplace=True)

df.info()

"""# Transformações

- Transformar Variável Multiple Lines o "No phone service" para "No".
- Transformar Variáveis "OnlineSecurity", "OnlineBackUp", "DeviceProtection", "TechSupport", "StreamingTV" e "StreamingMovies" de "No internet services" para "No".
- Transformar Charges Total em float.
- Separar variáveis categóricas das numéricas.
- Fazer a codificação das Variáveis Categóricas.
"""

df['MultipleLines'] = df['MultipleLines'].replace('No phone service', 'No')
df['OnlineSecurity'] = df['OnlineSecurity'].replace('No internet service', 'No')
df['OnlineBackup'] = df['OnlineBackup'].replace('No internet service', 'No')
df['DeviceProtection'] = df['DeviceProtection'].replace('No internet service', 'No')
df['TechSupport'] = df['TechSupport'].replace('No internet service', 'No')
df['StreamingTV'] = df['StreamingTV'].replace('No internet service', 'No')
df['StreamingMovies'] = df['StreamingMovies'].replace('No internet service', 'No')

for coluna in df.columns:
    valores_unicos = df[coluna].unique()  # Obtém os valores únicos
    print(f"Coluna: {coluna}")
    print(f"Valores únicos: {valores_unicos}\n")

df['ChargesTotal'] = df['ChargesTotal'].astype(float)
df.info()

# Parece que temos algum valor na coluna que está como string. Por isso foi identificado como object.

# Criar uma máscara para identificar valores inválidos
mask = pd.to_numeric(df['ChargesTotal'], errors='coerce').isna()

# Exibir as linhas problemáticas
df_problematicos = df[mask]
print(df_problematicos)

valores_invalidos = df.loc[mask, 'ChargesTotal'].unique()
print("Valores problemáticos encontrados:", valores_invalidos)

df['ChargesTotal'] = pd.to_numeric(df['ChargesTotal'], errors='coerce')  # Converte para float, substituindo erros por NaN
df.info()

df.dropna()

df.dropna(inplace=True)
df.info()

# Verificando IDs duplicados para indexar
df['ID'].duplicated().value_counts()

df.set_index('ID', inplace=True)
df.head()

for coluna in df.columns:
    plt.figure(figsize=(8, 6))
    sns.histplot(data=df, x=coluna, kde=True)
    plt.title(f'Histograma da Variável: {coluna}')
    plt.xlabel(coluna)

for coluna in df.columns:
    plt.figure(figsize=(8, 6))
    if coluna == 'Churn':
        continue
    else:
        sns.countplot(data=df, x=coluna, hue='Churn')
        plt.title(f'Distribuição da Variável: {coluna} por Churn')
    plt.xlabel(coluna)
    plt.xticks(rotation=45, ha='right')
    plt.show()

"""# Conclusões das Análises dos Gráficos de Distribuição


## Distribuições Desiguais:

- Temos um número muito mais alto de contagens para Não Churn que Sim Churn
- Senioridade está desigual, poucos clientes idosos.
- Dependentes está desigual
- Acúmulo de Tempo de contrato nos valores mais baixos
- PhoneService
- Online Security
- Online Backup
- Device Protection
- TechSupport
- StreamingTV
- StreamingMovies
- Acúmulo de ChargesMonthly e Total nas faixas menores, o que faz sentido pro ChargesTotal já que temos um número de clientes com poucos meses de contrato. Mas ChargesMonthly indica que temos um grande número de clientes com ticket baixo.

## Distribuições Iguais:
- A distribuiçõa de Gênero está equivalente.
- Parceiros está igual.
- Linhas Múltiplas
- InternetService
- Contract
- Paperless Billing
- Payment Method

# Hipóteses Até agora

- Entre homens e mulheres não vemos um padrão maior de churn por gênero.
- Entre os idosos, vemos uma taxa de cancelamento muito alta.
- Clientes que não possuem parceiros tendem a cancelar em torno de 2x mais.
- Existem mais clientes sem dependentes, porém os clientes com dependentes possuem uma taxa de cancelamento significativamente menor.
- A contagem alta de Churns em clientes com poucos meses de contrato demonstra uma taxa de cancelamento alta para os primeiros meses de contratação.
- Existe um número muito superior de clientes com contratação de serviços telefônicos, porém a taxa de churn aparenta estar proporcionalmente igual.
- Temos mais clientes SEM múltiplas linhas, mas a taxa de churn para os que tem é significativamente maior.
- A taxa de cancelamento para clientes com serviço de internet por fibra ótica extremamente alta, beirando os 50%. O que indica possível problema com o tipo de serviço.
- Temos mais clientes sem segurança online e com maior taxa de cancelamento do que aqueles que TEM segurança online.
- Mais clientes sem backup online, com uma taxa de cancelamento ligeiramente menor para aqueles que possuem backup online.
- O mesmo acontece para os clientes que possuem proteção de dispositivos.
- Clientes com suporte técnico tem uma taxa de churn 2x menor.
- Clientes sem StreamingTV possuem taxa de cancelamento menor, indicando possível problema com o tipo de serviço.
- O mesmo acontece para clientes sem StreamingMovies.
- Clientes com contrato mês a mês tem um Churn muito alto, em torno de 40%.
- Clientes com faturamento sem papel cancelam muito mais.
- Clientes que pagam com cheque eletrônico cancelam em torno de 40%.
- Não parece haver um padrão de churn em relação ao preço mensal.
- Distribuições desiguais podem fazer ser necessário utilizar uma reamostragem dos dados para evitar enviesamento do modelo. Utilizar outras métricas além de Acurácia, como F1-score, Recall e ROC-AUC.

# Desafios Extras
- Traduzir Colunas
- Criar Coluna de Conta Diária

Por aprendizado e querer colocar em prática a integração com API da OpenAI, vou fazer a tradução utilizando modelos de IA.
"""

# Configurando API Key
api_key = os.getenv("OPENAI_API_KEY")
client = OpenAI(api_key=api_key)

def obter_resposta_gpt(nome,modelo="gpt-4o",client=client,persona=None):

    prompt = f"""
    Abaixo temos o nome de uma coluna em um dataset. Sua tarefa consiste em traduzir o nome para o Português Brasileiro, que será o novo nome da coluna, e deverá obedecer:
    - sem acentos,
    - utilizando '_' no lugar de espaços,
    - Primeira letra de cada palavra em Maiúsculo,
    - Preserve termos em inglês que sejam utilizados em português, como exemplo 'Streaming'.

    Termo:
    '''{nome}'''

    Observação: Mantenha a formatação de escrita do termo. Retorne apenas o nome da coluna traduzido.
    """

    if persona:
        messages_arg = [
            {"role": "assistant", "content": persona},
            {"role": "user", "content": prompt}
        ]
    else:
        messages_arg = [{"role": "user", "content": prompt}]

    resposta = client.chat.completions.create(
        model=modelo,
        messages=messages_arg,
        temperature=0
    )

    # Extraindo o texto da resposta
    conteudo_resposta = resposta.choices[0].message.content

    return conteudo_resposta

# Testando Função API
resposta = obter_resposta_gpt("StreamingTV")
print(resposta)

# Preservando DF
df_manipulacao = df.copy()

novos_nomes = {}

for coluna in df.columns:
    traducao = obter_resposta_gpt(coluna)
    novos_nomes[coluna] = traducao.title()
    print(f"Traduzido '{coluna}' por '{traducao}'\n")

df_manipulacao.rename(columns=novos_nomes, inplace=True)

print(df_manipulacao.head())

"""# Criar Coluna de Conta Diária"""

df_manipulacao['Cobrancas_Diarias'] = (df_manipulacao['Cobrancas_Mensais'] / 30).round(2)
df_manipulacao.head()

"""# Separa em Categóricas e Numéricas"""

df_numericas = df_manipulacao[['Tempo_De_Contrato', 'Cobrancas_Mensais', 'Cobrancas_Totais', 'Cobrancas_Diarias']]
df_categoricas = df_manipulacao.drop(columns=['Tempo_De_Contrato', 'Cobrancas_Mensais', 'Cobrancas_Totais', 'Cobrancas_Diarias'])

df_numericas.head()

df_categoricas.head()

"""# Fazer Codificação das Variáveis Categóricas

Como o objetivo é fazer a previsão de churn, vamos utilizar Árvores de Decisão para isso. Então não vamos ter problemas com label encoding.
"""

encoder = LabelEncoder()

for coluna in df_categoricas.columns:
    df_categoricas[coluna] = encoder.fit_transform(df_categoricas[coluna])

df_categoricas.head()

df_final = pd.merge(df_numericas, df_categoricas, on = 'ID', how = 'inner')
df_final.head()

"""# Data Frame Final

Agora que temos o df final e transformado, podemos focar mais nas análises dos dados em si do que na integridade e formato dos dados.

1. Relembrar as informações gerais do dataset.
2. Verificar a Distribuição das variáveis
3. Analisar outliers
4. Analisar a variável target (Churn - Cancelamento)
5. Correlação entre variáveis
6. Relação das Variáveis com a variável target.

"""

df_final.info()

df_final.shape

df_final.describe()

correlacao = df_final.corr()
plt.figure(figsize=(18, 6))
sns.heatmap(correlacao, annot=True, cmap="coolwarm", fmt=".2f", linewidths=0.5)

plt.title("Heatmap de Correlação")
plt.show()

"""# Resumo Desta Etapa

1. Extraímos os Dados
2. Criamos o DataFrame
3. Exploramos os dados e identificamos tamanho, variáveis, tipos de dados, valores faltantes.
4. Corrigimos os valores faltantes e removemos, ajustamos os nomes das colunas, fizemos uma investigação inicial da distribuição dos dados.
5. Investigamos melhor a distribuição dos dados e procuramos padrões entre as distribuições da variável target com as variáveis independentes.
6. Levantamos hipóteses das análises.
7. Traduzimos os nomes das colunas automaticamente utilizando API da OpenAI (para aprendizado).
8. Criamos a coluna de Cobranças Diária (desafio extra).
9. Separamos o DF em variáveis numéricas e categóricas.
10. Fizemos Encoding das variáveis categóricas utilizando Label Encoder.
11. Unimos as variáveis numéricas com as categóricas após a codificação.
12. Puxamos as informações estatísticas e gerais do data frame para relembrar.
13. Fizemos um Heatmap de correlação entre as variáveis.

# Conclusões das Análises dos Gráficos de Distribuição


## Distribuições Desiguais:

- Temos um número muito mais alto de contagens para Não Churn que Sim Churn
- Senioridade está desigual, poucos clientes idosos.
- Dependentes está desigual
- Acúmulo de Tempo de contrato nos valores mais baixos
- PhoneService
- Online Security
- Online Backup
- Device Protection
- TechSupport
- StreamingTV
- StreamingMovies
- Acúmulo de ChargesMonthly e Total nas faixas menores, o que faz sentido pro ChargesTotal já que temos um número de clientes com poucos meses de contrato. Mas ChargesMonthly indica que temos um grande número de clientes com ticket baixo.

## Distribuições Iguais:
- A distribuiçõa de Gênero está equivalente.
- Parceiros está igual.
- Linhas Múltiplas
- InternetService
- Contract
- Paperless Billing
- Payment Method

## Hipóteses Levantadas

- Entre homens e mulheres não vemos um padrão maior de churn por gênero.
- Entre os idosos, vemos uma taxa de cancelamento muito alta.
- Clientes que não possuem parceiros tendem a cancelar em torno de 2x mais.
- Existem mais clientes sem dependentes, porém os clientes com dependentes possuem uma taxa de cancelamento significativamente menor.
- A contagem alta de Churns em clientes com poucos meses de contrato demonstra uma taxa de cancelamento alta para os primeiros meses de contratação.
- Existe um número muito superior de clientes com contratação de serviços telefônicos, porém a taxa de churn aparenta estar proporcionalmente igual.
- Temos mais clientes SEM múltiplas linhas, mas a taxa de churn para os que tem é significativamente maior.
- A taxa de cancelamento para clientes com serviço de internet por fibra ótica extremamente alta, beirando os 50%. O que indica possível problema com o tipo de serviço.
- Temos mais clientes sem segurança online e com maior taxa de cancelamento do que aqueles que TEM segurança online.
- Mais clientes sem backup online, com uma taxa de cancelamento ligeiramente menor para aqueles que possuem backup online.
- O mesmo acontece para os clientes que possuem proteção de dispositivos.
- Clientes com suporte técnico tem uma taxa de churn 2x menor.
- Clientes sem StreamingTV possuem taxa de cancelamento menor, indicando possível problema com o tipo de serviço.
- O mesmo acontece para clientes sem StreamingMovies.
- Clientes com contrato mês a mês tem um Churn muito alto, em torno de 40%.
- Clientes com faturamento sem papel cancelam muito mais.
- Clientes que pagam com cheque eletrônico cancelam em torno de 40%.
- Não parece haver um padrão de churn em relação ao preço mensal.
- Distribuições desiguais podem fazer ser necessário utilizar uma reamostragem dos dados para evitar enviesamento do modelo. Utilizar outras métricas além de Acurácia, como F1-score, Recall e ROC-AUC.
"""

